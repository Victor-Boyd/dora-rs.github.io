"use strict";(self.webpackChunkdora_rs_github_io=self.webpackChunkdora_rs_github_io||[]).push([[33],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>f});var o=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},s=Object.keys(e);for(o=0;o<s.length;o++)t=s[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)t=s[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var i=o.createContext({}),l=function(e){var n=o.useContext(i),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},c=function(e){var n=l(e.components);return o.createElement(i.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},_=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,s=e.originalType,i=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),d=l(t),_=a,f=d["".concat(i,".").concat(_)]||d[_]||u[_]||s;return t?o.createElement(f,r(r({ref:n},c),{},{components:t})):o.createElement(f,r({ref:n},c))}));function f(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var s=t.length,r=new Array(s);r[0]=_;var p={};for(var i in n)hasOwnProperty.call(n,i)&&(p[i]=n[i]);p.originalType=e,p[d]="string"==typeof e?e:a,r[1]=p;for(var l=2;l<s;l++)r[l]=t[l];return o.createElement.apply(null,r)}return o.createElement.apply(null,t)}_.displayName="MDXCreateElement"},5626:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>p,toc:()=>l});var o=t(7462),a=(t(7294),t(3905));const s={},r="FOT operator",p={unversionedId:"nodes_operators/fot_op",id:"nodes_operators/fot_op",title:"FOT operator",description:"The Frenet Optimal Planner Operator is based on https://github.com/erdos-project/frenetoptimaltrajectoryplanner/ and wrap the different elements obstacles, position, speed ... into a frenet consumable format.",source:"@site/i18n/zh-CN/docusaurus-plugin-content-docs/current/nodes_operators/fot_op.md",sourceDirName:"nodes_operators",slug:"/nodes_operators/fot_op",permalink:"/zh-CN/docs/nodes_operators/fot_op",draft:!1,editUrl:"https://crowdin.com/dora-rs/zh-CN",tags:[],version:"current",frontMatter:{},sidebar:"nodes_operators",previous:{title:"search",permalink:"/zh-CN/docs/nodes_operators/search"},next:{title:"MiDaS",permalink:"/zh-CN/docs/nodes_operators/midas_op"}},i={},l=[{value:"Graph Description",id:"graph-description",level:2},{value:"Graph Viz",id:"graph-viz",level:2},{value:"Methods",id:"methods",level:2},{value:"<code>__init__()</code>",id:"__init__",level:3},{value:"<code>.on_event(...)</code>",id:"on_event",level:3},{value:"<code>.on_input(...)</code>",id:"on_input",level:3}],c={toc:l},d="wrapper";function u(e){let{components:n,...t}=e;return(0,a.kt)(d,(0,o.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"fot-operator"},"FOT operator"),(0,a.kt)("p",null,"The Frenet Optimal Planner Operator is based on ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/erdos-project/frenet_optimal_trajectory_planner/"},"https://github.com/erdos-project/frenet_optimal_trajectory_planner/")," and wrap the different elements ",(0,a.kt)("inlineCode",{parentName:"p"},"obstacles"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"position"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"speed")," ... into a frenet consumable format."),(0,a.kt)("p",null,"FOT inputs are:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'initial_conditions = {\n    "ps": 0,\n    "target_speed": # The target speed\n    "pos": # The x, y current position\n    "vel": # The vx, vy current speed\n    "wp": # [[x, y], ... n_waypoints ] desired waypoints\n    "obs": # [[min_x, min_y, max_x, max_y], ... ] obstacles on the way\n}\n')),(0,a.kt)("p",null,"There is also a set of hyperparameters that are described below."),(0,a.kt)("p",null,"As our obstacles are defined as 3D dot we need to transform those dot into ",(0,a.kt)("inlineCode",{parentName:"p"},"[min_x, min_y, max_x, max_y]")," format. We do that within the ",(0,a.kt)("inlineCode",{parentName:"p"},"get_obstacle_list")," function. This approximation is very basic and probably need to be revisited."),(0,a.kt)("p",null,"The output is either a successful trajectory that we can feed into PID. Or it is a failure in which case we send the current position as waypoint."),(0,a.kt)("h2",{id:"graph-description"},"Graph Description"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"  - id: fot_op\n    operator:\n      python: ../../operators/fot_op.py\n      outputs:\n        - waypoints\n      inputs:\n        position: oasis_agent/position\n        speed: oasis_agent/speed\n        obstacles: obstacle_location_op/obstacles\n        gps_waypoints: carla_gps_op/gps_waypoints\n")),(0,a.kt)("h2",{id:"graph-viz"},"Graph Viz"),(0,a.kt)("mermaid",{value:"        flowchart TB\n  oasis_agent\nsubgraph carla_gps_op\n  carla_gps_op/op[op]\nend\nsubgraph fot_op\n  fot_op/op[op]\nend\nsubgraph obstacle_location_op\n  obstacle_location_op/op[op]\nend\nsubgraph pid_control_op\n  pid_control_op/op[op]\nend\n  carla_gps_op/op -- gps_waypoints --\x3e fot_op/op\n  obstacle_location_op/op -- obstacles --\x3e fot_op/op\n  oasis_agent -- position --\x3e fot_op/op\n  oasis_agent -- speed --\x3e fot_op/op\n  fot_op/op -- waypoints --\x3e pid_control_op/op"}),(0,a.kt)("h2",{id:"methods"},"Methods"),(0,a.kt)("h3",{id:"__init__"},(0,a.kt)("inlineCode",{parentName:"h3"},"__init__()")),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Source Code"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'    def __init__(self):\n        self.obstacles = np.array([])\n        self.lanes = np.array([])\n        self.position = []\n        self.speed = []\n        self.last_position = []\n        self.waypoints = []\n        self.gps_waypoints = np.array([])\n        self.last_obstacles = np.array([])\n        self.obstacle_metadata = {}\n        self.gps_metadata = {}\n        self.metadata = {}\n        self.orientation = None\n        self.outputs = []\n        self.hyperparameters = {\n            "max_speed": 25.0,\n            "max_accel": 45.0,\n            "max_curvature": 55.0,\n            "max_road_width_l": 0.1,\n            "max_road_width_r": 0.1,\n            "d_road_w": 0.5,\n            "dt": 0.5,\n            "maxt": 5.0,\n            "mint": 2.0,\n            "d_t_s": 5,\n            "n_s_sample": 2.0,\n            "obstacle_clearance": 0.1,\n            "kd": 1.0,\n            "kv": 0.1,\n            "ka": 0.1,\n            "kj": 0.1,\n            "kt": 0.1,\n            "ko": 0.1,\n            "klat": 1.0,\n            "klon": 1.0,\n            "num_threads": 0,  # set 0 to avoid using threaded algorithm\n        }\n        self.conds = {\n            "s0": 0,\n            "target_speed": TARGET_SPEED,\n        }  # paste output from debug log\n\n\n'))),(0,a.kt)("h3",{id:"on_event"},(0,a.kt)("inlineCode",{parentName:"h3"},".on_event(...)")),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Source Code"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'\n    def on_event(\n        self,\n        dora_event: dict,\n        send_output: Callable[[str, bytes], None],\n    ) -> DoraStatus:\n        if dora_event["type"] == "INPUT":\n            return self.on_input(dora_event, send_output)\n        return DoraStatus.CONTINUE\n\n\n'))),(0,a.kt)("h3",{id:"on_input"},(0,a.kt)("inlineCode",{parentName:"h3"},".on_input(...)")),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Source Code"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'\n    def on_input(\n        self,\n        dora_input: dict,\n        send_output: Callable[[str, bytes], None],\n    ):\n\n        if dora_input["id"] == "position":\n            self.last_position = self.position\n            self.position = np.array(dora_input["value"]).view(np.float32)\n            if len(self.last_position) == 0:\n                self.last_position = self.position\n            return DoraStatus.CONTINUE\n\n        elif dora_input["id"] == "speed":\n            self.speed = np.array(dora_input["value"]).view(np.float32)\n            return DoraStatus.CONTINUE\n\n        elif dora_input["id"] == "obstacles":\n            obstacles = (\n                np.array(dora_input["value"]).view(np.float32).reshape((-1, 5))\n            )\n            if len(self.last_obstacles) > 0:\n                self.obstacles = np.concatenate(\n                    [self.last_obstacles, obstacles]\n                )\n            else:\n                self.obstacles = obstacles\n\n        elif dora_input["id"] == "global_lanes":\n            lanes = (\n                np.array(dora_input["value"])\n                .view(np.float32)\n                .reshape((-1, 60, 3))\n            )\n            self.lanes = lanes\n            return DoraStatus.CONTINUE\n\n        elif "gps_waypoints" == dora_input["id"]:\n            waypoints = np.array(dora_input["value"]).view(np.float32)\n            waypoints = waypoints.reshape((-1, 3))[:, :2]\n            self.gps_waypoints = waypoints\n            return DoraStatus.CONTINUE\n\n        if len(self.gps_waypoints) == 0:\n            print("No waypoints")\n            send_output(\n                "waypoints",\n                self.gps_waypoints.tobytes(),\n                dora_input["metadata"],\n            )\n            return DoraStatus.CONTINUE\n\n        elif len(self.position) == 0 or len(self.speed) == 0:\n            return DoraStatus.CONTINUE\n\n        [x, y, z, rx, ry, rz, rw] = self.position\n        [_, _, yaw] = R.from_quat([rx, ry, rz, rw]).as_euler(\n            "xyz", degrees=False\n        )\n\n        gps_obstacles = get_obstacle_list(\n            self.position, self.obstacles, self.gps_waypoints\n        )\n\n        if len(self.lanes) > 0:\n            lanes = get_lane_list(self.position, self.lanes, self.gps_waypoints)\n            obstacles = np.concatenate([gps_obstacles, lanes])\n        else:\n            obstacles = gps_obstacles\n        initial_conditions = {\n            "ps": 0,\n            "target_speed": self.conds["target_speed"],\n            "pos": self.position[:2],\n            "vel": (np.clip(LA.norm(self.speed), 0.5, 40))\n            * np.array([np.cos(yaw), np.sin(yaw)]),\n            "wp": self.gps_waypoints,\n            "obs": obstacles,\n        }\n\n        (\n            result_x,\n            result_y,\n            speeds,\n            ix,\n            iy,\n            iyaw,\n            d,\n            s,\n            speeds_x,\n            speeds_y,\n            misc,\n            costs,\n            success,\n        ) = fot_wrapper.run_fot(initial_conditions, self.hyperparameters)\n\n        if not success:\n            initial_conditions["wp"] = initial_conditions["wp"][:5]\n            print(f"fot failed. stopping with {initial_conditions}.")\n            target_distance = LA.norm(\n                self.gps_waypoints[-1] - self.position[:2]\n            )\n            print(f"Distance to target: {target_distance}")\n            for obstacle in self.obstacles:\n                print(\n                    f"obstacles:{obstacle}, label: {LABELS[int(obstacle[-1])]}"\n                )\n\n            send_output(\n                "waypoints",\n                pa.array(np.array([x, y, 0.0], np.float32).view(np.uint8)),\n                dora_input["metadata"],\n            )\n            return DoraStatus.CONTINUE\n\n        self.waypoints = np.concatenate([result_x, result_y]).reshape((2, -1)).T\n\n        self.outputs = np.ascontiguousarray(\n            np.concatenate([result_x, result_y, speeds])\n            .reshape((3, -1))\n            .T.astype(np.float32)\n        )\n        send_output(\n            "waypoints",\n            pa.array(self.outputs.ravel().view(np.uint8)),\n            dora_input["metadata"],\n        )\n        return DoraStatus.CONTINUE\n\n\n'))))}u.isMDXComponent=!0}}]);