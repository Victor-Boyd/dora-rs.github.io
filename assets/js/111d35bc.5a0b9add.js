"use strict";(self.webpackChunkdora_rs_github_io=self.webpackChunkdora_rs_github_io||[]).push([[8908],{3905:(o,e,t)=>{t.d(e,{Zo:()=>c,kt:()=>y});var n=t(7294);function r(o,e,t){return e in o?Object.defineProperty(o,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):o[e]=t,o}function a(o,e){var t=Object.keys(o);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(o);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(o,e).enumerable}))),t.push.apply(t,n)}return t}function i(o){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?a(Object(t),!0).forEach((function(e){r(o,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(o,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(e){Object.defineProperty(o,e,Object.getOwnPropertyDescriptor(t,e))}))}return o}function p(o,e){if(null==o)return{};var t,n,r=function(o,e){if(null==o)return{};var t,n,r={},a=Object.keys(o);for(n=0;n<a.length;n++)t=a[n],e.indexOf(t)>=0||(r[t]=o[t]);return r}(o,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(o);for(n=0;n<a.length;n++)t=a[n],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(o,t)&&(r[t]=o[t])}return r}var s=n.createContext({}),l=function(o){var e=n.useContext(s),t=e;return o&&(t="function"==typeof o?o(e):i(i({},e),o)),t},c=function(o){var e=l(o.components);return n.createElement(s.Provider,{value:e},o.children)},d="mdxType",u={inlineCode:"code",wrapper:function(o){var e=o.children;return n.createElement(n.Fragment,{},e)}},g=n.forwardRef((function(o,e){var t=o.components,r=o.mdxType,a=o.originalType,s=o.parentName,c=p(o,["components","mdxType","originalType","parentName"]),d=l(t),g=r,y=d["".concat(s,".").concat(g)]||d[g]||u[g]||a;return t?n.createElement(y,i(i({ref:e},c),{},{components:t})):n.createElement(y,i({ref:e},c))}));function y(o,e){var t=arguments,r=e&&e.mdxType;if("string"==typeof o||r){var a=t.length,i=new Array(a);i[0]=g;var p={};for(var s in e)hasOwnProperty.call(e,s)&&(p[s]=e[s]);p.originalType=o,p[d]="string"==typeof o?o:r,i[1]=p;for(var l=2;l<a;l++)i[l]=t[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,t)}g.displayName="MDXCreateElement"},1425:(o,e,t)=>{t.r(e),t.d(e,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>p,toc:()=>l});var n=t(7462),r=(t(7294),t(3905));const a={sidebar_position:5},i="Control",p={unversionedId:"guides/dora-drives/control",id:"guides/dora-drives/control",title:"Control",description:"PID Controller",source:"@site/docs/guides/dora-drives/control.mdx",sourceDirName:"guides/dora-drives",slug:"/guides/dora-drives/control",permalink:"/docs/guides/dora-drives/control",draft:!1,editUrl:"https://github.com/dora-rs/dora-rs.github.io/edit/main/docs/guides/dora-drives/control.mdx",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"guides",previous:{title:"Planning",permalink:"/docs/guides/dora-drives/planning"},next:{title:"Support Matrix",permalink:"/docs/guides/support-matrix"}},s={},l=[{value:"PID Controller",id:"pid-controller",level:2},{value:"Control",id:"control-1",level:2},{value:"Fully looped graph",id:"fully-looped-graph",level:2}],c={toc:l},d="wrapper";function u(o){let{components:e,...t}=o;return(0,r.kt)(d,(0,n.Z)({},c,t,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"control"},"Control"),(0,r.kt)("h2",{id:"pid-controller"},"PID Controller"),(0,r.kt)("p",null,"To translate our waypoints to ",(0,r.kt)("inlineCode",{parentName:"p"},"throttle, steering and brake")," control, we're using a Proportional Integral Derivative (PID) controller that is able to adjust the throttle, steering and breaking according to the car position and speed by comparing it to the desired waypoints. The code can be found in ",(0,r.kt)("inlineCode",{parentName:"p"},"operator/pid_control_op.py"),"."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"For more information on ",(0,r.kt)("inlineCode",{parentName:"p"},"pid"),", go on ",(0,r.kt)("a",{parentName:"p",href:"/docs/nodes_operators/pid_control_op"},"our ",(0,r.kt)("inlineCode",{parentName:"a"},"pid")," detail page"))),(0,r.kt)("h2",{id:"control-1"},"Control"),(0,r.kt)("p",null,"The actual command being applied to the car is controlled within the ",(0,r.kt)("inlineCode",{parentName:"p"},"oasis_agent"),"."),(0,r.kt)("h2",{id:"fully-looped-graph"},"Fully looped graph"),(0,r.kt)("p",null,"We have now all our starter kit node. They will look like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"nodes:\n  - id: oasis_agent\n    custom:\n      inputs:\n        control: pid_control_op/control\n        tick: dora/timer/millis/400\n      outputs:\n        - position\n        - speed\n        - image\n        - objective_waypoints\n        - lidar_pc\n        - opendrive\n      source: shell\n      # args: >\n      #   python3 $SIMULATE --output \n      #   --oasJson --criteriaConfig $CRITERIA\n      #   --openscenario $XOSC\n      #   --agent $TEAM_AGENT\n      #   --agentConfig $TEAM_AGENT_CONF\n      #   --destination $DESTINATION\n      #\n      # or for Carla Standalone:\n      #\n      args: python3 ../../carla/carla_source_node.py\n\n  - id: carla_gps_op\n    operator:\n      python: ../../carla/carla_gps_op.py\n      outputs:\n        - gps_waypoints\n      inputs:\n        opendrive: oasis_agent/opendrive\n        objective_waypoints: oasis_agent/objective_waypoints\n        position: oasis_agent/position\n\n  - id: yolov5\n    operator: \n      outputs:\n        - bbox\n      inputs:\n        image: oasis_agent/image\n      python: ../../operators/yolov5_op.py\n\n  - id: obstacle_location_op\n    operator: \n      outputs:\n        - obstacles\n      inputs:\n        lidar_pc: oasis_agent/lidar_pc\n        obstacles_bbox: yolov5/bbox\n        position: oasis_agent/position\n      python: ../../operators/obstacle_location_op.py\n\n  - id: fot_op\n    operator:\n      python: ../../operators/fot_op.py\n      outputs:\n        - waypoints\n      inputs:\n        position: oasis_agent/position\n        speed: oasis_agent/speed\n        obstacles: obstacle_location_op/obstacles\n        gps_waypoints: carla_gps_op/gps_waypoints\n \n  - id: pid_control_op\n    operator:\n      python: ../../operators/pid_control_op.py\n      outputs:\n        - control\n      inputs:\n        position: oasis_agent/position\n        speed: oasis_agent/speed\n        waypoints: fot_op/waypoints\n\n  - id: plot\n    operator:\n      python: ../../operators/plot.py\n      inputs:\n        image: oasis_agent/image\n        obstacles_bbox: yolov5/bbox\n        obstacles: obstacle_location_op/obstacles\n        gps_waypoints: carla_gps_op/gps_waypoints\n        position: oasis_agent/position\n        waypoints: fot_op/waypoints\n        control: pid_control_op/control\n")),(0,r.kt)("p",null,"To run a running car example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"dora up\ndora start graphs/oasis/oasis_full.yaml --attach\n")),(0,r.kt)("p",null,"\ud83d\ude0e We now have a working autonomous car!"),(0,r.kt)("p",null,"You might have noticed that improvement can be done in many place."),(0,r.kt)("p",null,"In case you need inspiration, we advise you check:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"operators/yolop_op.py")," that enables you to detect lanes. It can be passed to the obstacle location to get the 3D position of the lanes. Those 3D position of lanes can then be passed to ",(0,r.kt)("inlineCode",{parentName:"li"},"fot")," to plan by taking into account lanes on the floor."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"operators/strong_sort.py")," that enables tracking 2D bounding box through times. This can be useul if you want to avoid moving vehicles."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"opertators/traffic_sign.py")," that is self-trained traffic light detection based on yolov7 and tt100k. THis can be useful to avoid traffic light.")))}u.isMDXComponent=!0}}]);