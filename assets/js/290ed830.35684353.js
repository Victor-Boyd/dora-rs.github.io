"use strict";(self.webpackChunkdora_rs_github_io=self.webpackChunkdora_rs_github_io||[]).push([[6735],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function a(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),d=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=d(e.components);return r.createElement(l.Provider,{value:t},e.children)},c="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},_=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,u=a(e,["components","mdxType","originalType","parentName"]),c=d(n),_=o,m=c["".concat(l,".").concat(_)]||c[_]||p[_]||i;return n?r.createElement(m,s(s({ref:t},u),{},{components:n})):r.createElement(m,s({ref:t},u))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,s=new Array(i);s[0]=_;var a={};for(var l in t)hasOwnProperty.call(t,l)&&(a[l]=t[l]);a.originalType=e,a[c]="string"==typeof e?e:o,s[1]=a;for(var d=2;d<i;d++)s[d]=n[d];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}_.displayName="MDXCreateElement"},6067:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>a,toc:()=>d});var r=n(7462),o=(n(7294),n(3905));const i={},s="Bridging ROS2",a={unversionedId:"guides/dora-ros2-bridges/dora-ros2-bridges",id:"guides/dora-ros2-bridges/dora-ros2-bridges",title:"Bridging ROS2",description:"dora-ros2-bridge is an extension that we have build for people to use ROS2 easily.",source:"@site/docs/guides/dora-ros2-bridges/dora-ros2-bridges.md",sourceDirName:"guides/dora-ros2-bridges",slug:"/guides/dora-ros2-bridges/",permalink:"/docs/guides/dora-ros2-bridges/",draft:!1,editUrl:"https://github.com/dora-rs/dora-rs.github.io/edit/main/docs/guides/dora-ros2-bridges/dora-ros2-bridges.md",tags:[],version:"current",frontMatter:{},sidebar:"guides",previous:{title:"Control",permalink:"/docs/guides/dora-drives/control"},next:{title:"Support Matrix",permalink:"/docs/guides/support-matrix"}},l={},d=[{value:"Why dora-ros2-bridge?",id:"why-dora-ros2-bridge",level:2},{value:"Getting Started in Python",id:"getting-started-in-python",level:2},{value:"Getting started in Rust",id:"getting-started-in-rust",level:2}],u={toc:d},c="wrapper";function p(e){let{components:t,...n}=e;return(0,o.kt)(c,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"bridging-ros2"},"Bridging ROS2"),(0,o.kt)("p",null,"dora-ros2-bridge is an extension that we have build for people to use ROS2 easily.\nOne of the main issue with ROS2 is the complex build system. It would have been really hard for people to use dora on top of the ros2 build system so we have build this bridsge to be ROS2 compiler free. In order to do that, we convert every message at runtime into arrow struct format. This can be use to rapidly use AI models through numpy, pandas, ..."),(0,o.kt)("h2",{id:"why-dora-ros2-bridge"},"Why dora-ros2-bridge?"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"See: ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/orgs/dora-rs/discussions/306"},"https://github.com/orgs/dora-rs/discussions/306"))),(0,o.kt)("p",null,"Current robotic community uses a lot of ROS2 for building robots. It's hard for them to switch entirely from ROS2. Building easy-to-use bridge for ROS 2 helps provide a simpler way to integrate and transition projects to/from dora. This also makes it easy to reuse ROS2 sensor node that does not provide any other API."),(0,o.kt)("h2",{id:"getting-started-in-python"},"Getting Started in Python"),(0,o.kt)("p",null,"The following example can operate a simulation of the ROS2 turtlebot using dora.\nIt does not requires any compilation from colcon and only needs to be run with dora."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport dora\nfrom dora import Node\n\nros2_context = dora.experimental.ros2_bridge.Ros2Context()\nros2_node = ros2_context.new_node(\n    "turtle_teleop", # name\n    "/ros2_demo", # namespace\n    dora.experimental.ros2_bridge.Ros2NodeOptions(rosout=True),\n)\n\n# Define a ROS2 QOS\ntopic_qos = dora.experimental.ros2_bridge.Ros2QosPolicies(\n    reliable=True, max_blocking_time=0.1\n)\n\n# Create a publisher to cmd_vel topic\nturtle_twist_topic = ros2_node.create_topic(\n    "/turtle1/cmd_vel", "geometry_msgs::Twist", topic_qos\n)\ntwist_writer = ros2_node.create_publisher(turtle_twist_topic)\n\n# Create a listener to pose topic\nturtle_pose_topic = ros2_node.create_topic(\n    "/turtle1/pose", "turtlesim::Pose", topic_qos\n)\npose_reader = ros2_node.create_subscription(turtle_pose_topic)\n\n# Create a dora node\ndora_node = Node()\n\n# Listen for both stream on the same loop as Python does not handle well multiprocessing\ndora_node.merge_external_events(pose_reader)\n\nfor i in range(500):\n    event = dora_node.next()\n    if event is None:\n        break\n    match event["kind"]:\n\n        # Dora event\n        case "dora":\n            match event["type"]:\n                case "INPUT":\n                    match event["id"]:\n                        case "direction":\n                            twist_writer.publish(event["value"])\n\n        # In this case ROS2 event\n        case "external":\n            pose = event.inner()[0].as_py()\n            dora_node.send_output("turtle_pose", event.inner())\n')),(0,o.kt)("h2",{id:"getting-started-in-rust"},"Getting started in Rust"),(0,o.kt)("p",null,"The following example can operate the ROS2 turtlebot using dora.\nIt does not need colcon and only needs to be compiled natively with ",(0,o.kt)("inlineCode",{parentName:"p"},"cargo")," and run with dora."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'use dora_node_api::{\n    self,\n    dora_core::config::DataId,\n    merged::{MergeExternal, MergedEvent},\n    DoraNode, Event,\n};\nuse dora_ros2_bridge::{\n    geometry_msgs::msg::{Twist, Vector3},\n    ros2_client::{self, ros2, NodeOptions},\n    rustdds::{self, policy},\n    turtlesim::msg::Pose,\n};\nuse eyre::Context;\n\nfn main() -> eyre::Result<()> {\n    let mut ros_node = init_ros_node()?;\n    let turtle_vel_publisher = create_vel_publisher(&mut ros_node)?;\n    let turtle_pose_reader = create_pose_reader(&mut ros_node)?;\n\n    // Initialize dora node\n    let output = DataId::from("pose".to_owned());\n    let (mut node, dora_events) = DoraNode::init_from_env()?;\n\n    // Merge both stream into one loop.\n    let merged = dora_events.merge_external(Box::pin(turtle_pose_reader.async_stream()));\n    let mut events = futures::executor::block_on_stream(merged);\n\n    for i in 0..1000 {\n        let event = match events.next() {\n            Some(input) => input,\n            None => break,\n        };\n\n        match event {\n            MergedEvent::Dora(event) => match event {\n                Event::Input {\n                    id,\n                    metadata: _,\n                    data: _,\n                } => match id.as_str() {\n                    "tick" => {\n                        let direction = Twist {\n                            linear: Vector3 {\n                                x: rand::random::<f64>() + 1.0,\n                                ..Default::default()\n                            },\n                            angular: Vector3 {\n                                z: (rand::random::<f64>() - 0.5) * 5.0,\n                                ..Default::default()\n                            },\n                        };\n                        println!("tick {i}, sending {direction:?}");\n                        turtle_vel_publisher.publish(direction).unwrap();\n                    }\n                    other => eprintln!("Ignoring unexpected input `{other}`"),\n                },\n                Event::Stop => println!("Received manual stop"),\n                other => eprintln!("Received unexpected input: {other:?}"),\n            },\n            MergedEvent::External(pose) => {\n                println!("received pose event: {pose:?}");\n                if let Ok((pose, _)) = pose {\n                    let serialized = serde_json::to_string(&pose)?;\n                    node.send_output_bytes(\n                        output.clone(),\n                        Default::default(),\n                        serialized.len(),\n                        serialized.as_bytes(),\n                    )?;\n                }\n            }\n        }\n    }\n\n    Ok(())\n}\n\nfn init_ros_node() -> eyre::Result<ros2_client::Node> {\n    let ros_context = ros2_client::Context::new().unwrap();\n\n    ros_context\n        .new_node(\n            "turtle_teleop", // name\n            "/ros2_demo",    // namespace\n            NodeOptions::new().enable_rosout(true),\n        )\n        .context("failed to create ros2 node")\n}\n\n// Publish on vel_cmd topic\nfn create_vel_publisher(\n    ros_node: &mut ros2_client::Node,\n) -> eyre::Result<ros2_client::Publisher<Twist>> {\n    let topic_qos: rustdds::QosPolicies = {\n        rustdds::QosPolicyBuilder::new()\n            .durability(policy::Durability::Volatile)\n            .liveliness(policy::Liveliness::Automatic {\n                lease_duration: ros2::Duration::DURATION_INFINITE,\n            })\n            .reliability(policy::Reliability::Reliable {\n                max_blocking_time: ros2::Duration::from_millis(100),\n            })\n            .history(policy::History::KeepLast { depth: 1 })\n            .build()\n    };\n\n    let turtle_cmd_vel_topic = ros_node\n        .create_topic(\n            "/turtle1/cmd_vel",\n            String::from("geometry_msgs::msg::dds_::Twist_"),\n            &topic_qos,\n        )\n        .context("failed to create topic")?;\n\n    // The point here is to publish Twist for the turtle\n    let turtle_cmd_vel_writer = ros_node\n        .create_publisher::<Twist>(&turtle_cmd_vel_topic, None)\n        .context("failed to create publisher")?;\n    Ok(turtle_cmd_vel_writer)\n}\n\n// Listen for pose topic\nfn create_pose_reader(\n    ros_node: &mut ros2_client::Node,\n) -> eyre::Result<ros2_client::Subscription<Pose>> {\n    let turtle_pose_topic = ros_node\n        .create_topic(\n            "/turtle1/pose",\n            String::from("turtlesim::msg::dds_::Pose_"),\n            &Default::default(),\n        )\n        .context("failed to create topic")?;\n    let turtle_pose_reader = ros_node\n        .create_subscription::<Pose>(&turtle_pose_topic, None)\n        .context("failed to create subscription")?;\n    Ok(turtle_pose_reader)\n}\n\n')))}p.isMDXComponent=!0}}]);