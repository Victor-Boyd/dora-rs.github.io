"use strict";(self.webpackChunkdora_rs_github_io=self.webpackChunkdora_rs_github_io||[]).push([[219],{3905:(t,e,o)=>{o.d(e,{Zo:()=>c,kt:()=>u});var n=o(7294);function a(t,e,o){return e in t?Object.defineProperty(t,e,{value:o,enumerable:!0,configurable:!0,writable:!0}):t[e]=o,t}function r(t,e){var o=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),o.push.apply(o,n)}return o}function i(t){for(var e=1;e<arguments.length;e++){var o=null!=arguments[e]?arguments[e]:{};e%2?r(Object(o),!0).forEach((function(e){a(t,e,o[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(o)):r(Object(o)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(o,e))}))}return t}function s(t,e){if(null==t)return{};var o,n,a=function(t,e){if(null==t)return{};var o,n,a={},r=Object.keys(t);for(n=0;n<r.length;n++)o=r[n],e.indexOf(o)>=0||(a[o]=t[o]);return a}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(n=0;n<r.length;n++)o=r[n],e.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(t,o)&&(a[o]=t[o])}return a}var p=n.createContext({}),l=function(t){var e=n.useContext(p),o=e;return t&&(o="function"==typeof t?t(e):i(i({},e),t)),o},c=function(t){var e=l(t.components);return n.createElement(p.Provider,{value:e},t.children)},f="mdxType",d={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},m=n.forwardRef((function(t,e){var o=t.components,a=t.mdxType,r=t.originalType,p=t.parentName,c=s(t,["components","mdxType","originalType","parentName"]),f=l(o),m=a,u=f["".concat(p,".").concat(m)]||f[m]||d[m]||r;return o?n.createElement(u,i(i({ref:e},c),{},{components:o})):n.createElement(u,i({ref:e},c))}));function u(t,e){var o=arguments,a=e&&e.mdxType;if("string"==typeof t||a){var r=o.length,i=new Array(r);i[0]=m;var s={};for(var p in e)hasOwnProperty.call(e,p)&&(s[p]=e[p]);s.originalType=t,s[f]="string"==typeof t?t:a,i[1]=s;for(var l=2;l<r;l++)i[l]=o[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,o)}m.displayName="MDXCreateElement"},1741:(t,e,o)=>{o.r(e),o.d(e,{assets:()=>p,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var n=o(7462),a=(o(7294),o(3905));const r={},i="FOT operator",s={unversionedId:"nodes_operators/fot_operator",id:"nodes_operators/fot_operator",title:"FOT operator",description:"The Frenet Optimal Planner Operator is based on https://github.com/erdos-project/frenetoptimaltrajectoryplanner/ and wrap the different elements obstacles, position, speed ... into a frenet consumable format.",source:"@site/docs/nodes_operators/fot_operator.md",sourceDirName:"nodes_operators",slug:"/nodes_operators/fot_operator",permalink:"/docs/nodes_operators/fot_operator",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/nodes_operators/fot_operator.md",tags:[],version:"current",frontMatter:{},sidebar:"nodes_operators",previous:{title:"Control operator",permalink:"/docs/nodes_operators/control_operator"},next:{title:"GPS operator",permalink:"/docs/nodes_operators/gps_operator"}},p={},l=[{value:"Graph Description",id:"graph-description",level:2},{value:"Graph visualisation",id:"graph-visualisation",level:2},{value:"Hyperparameter descriptions",id:"hyperparameter-descriptions",level:2}],c={toc:l},f="wrapper";function d(t){let{components:e,...o}=t;return(0,a.kt)(f,(0,n.Z)({},c,o,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"fot-operator"},"FOT operator"),(0,a.kt)("p",null,"The Frenet Optimal Planner Operator is based on ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/erdos-project/frenet_optimal_trajectory_planner/"},"https://github.com/erdos-project/frenet_optimal_trajectory_planner/")," and wrap the different elements ",(0,a.kt)("inlineCode",{parentName:"p"},"obstacles"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"position"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"speed")," ... into a frenet consumable format. "),(0,a.kt)("p",null,"FOT inputs are:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'initial_conditions = {\n    "ps": 0,\n    "target_speed": # The target speed\n    "pos": # The x, y current position\n    "vel": # The vx, vy current speed\n    "wp": # [[x, y], ... n_waypoints ] desired waypoints\n    "obs": # [[min_x, min_y, max_x, max_y], ... ] obstacles on the way\n}\n')),(0,a.kt)("p",null,"There is also a set of hyperparameters that are described below."),(0,a.kt)("p",null,"As our obstacles are defined as 3D dot we need to transform those dot into ",(0,a.kt)("inlineCode",{parentName:"p"},"[min_x, min_y, max_x, max_y]")," format. We do that within the ",(0,a.kt)("inlineCode",{parentName:"p"},"get_obstacle_list")," function. This approximation is very basic and probably need to be revisited."),(0,a.kt)("p",null,"The output is either a successful trajectory that we can feed into PID. Or it is a failure in which case we send the current position as waypoint."),(0,a.kt)("h2",{id:"graph-description"},"Graph Description"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"  - id: fot_op\n    operator:\n      python: ../../operators/fot_op.py\n      outputs:\n        - waypoints\n      inputs:\n        position: agent/position\n        speed: agent/speed\n        obstacles: obstacle_location_op/obstacles\n        gps_waypoints: carla_gps_op/gps_waypoints\n")),(0,a.kt)("h2",{id:"graph-visualisation"},"Graph visualisation"),(0,a.kt)("div",{align:"center"},(0,a.kt)("mermaid",{value:"        flowchart TB\n  agent\nsubgraph carla_gps_op\n  carla_gps_op/op[op]\nend\nsubgraph fot_op\n  fot_op/op[op]\nend\nsubgraph obstacle_location_op\n  obstacle_location_op/op[op]\nend\nsubgraph pid_control_op\n  pid_control_op/op[op]\nend\n  carla_gps_op/op -- gps_waypoints --\x3e fot_op/op\n  obstacle_location_op/op -- obstacles --\x3e fot_op/op\n  agent -- position --\x3e fot_op/op\n  agent -- speed --\x3e fot_op/op\n  fot_op/op -- waypoints --\x3e pid_control_op/op"})),(0,a.kt)("h2",{id:"hyperparameter-descriptions"},"Hyperparameter descriptions"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"        initial_conditions (dict): dict containing the following items\n            ps (float): previous longitudinal position\n            target_speed (float): target speed [m/s]\n            pos (np.ndarray([float, float])): initial position in global coord\n            vel (np.ndarray([float, float])): initial velocity [m/s]\n            wp (np.ndarray([float, float])): list of global waypoints\n            obs (np.ndarray([float, float, float, float])): list of obstacles\n                as: [lower left x, lower left y, upper right x, upper right y]\n        hyperparameters (dict): a dict of optional hyperparameters\n            max_speed (float): maximum speed [m/s]\n            max_accel (float): maximum acceleration [m/s^2]\n            max_curvature (float): maximum curvature [1/m]\n            max_road_width_l (float): maximum road width to the left [m]\n            max_road_width_r (float): maximum road width to the right [m]\n            d_road_w (float): road width sampling discretization [m]\n            dt (float): time sampling discretization [s]\n            maxt (float): max prediction horizon [s]\n            mint (float): min prediction horizon [s]\n            d_t_s (float): target speed sampling discretization [m/s]\n            n_s_sample (float): sampling number of target speed\n            obstacle_clearance (float): obstacle radius [m]\n            kd (float): positional deviation cost\n            kv (float): velocity cost\n            ka (float): acceleration cost\n            kj (float): jerk cost\n            kt (float): time cost\n            ko (float): dist to obstacle cost\n            klat (float): lateral cost\n            klon (float): longitudinal cost\n    Returns:\n        result_x (np.ndarray(float)): x positions of fot, if it exists\n        result_y (np.ndarray(float)): y positions of fot, if it exists\n        speeds (np.ndarray(float)): speeds of fot, if it exists\n        ix (np.ndarray(float)): spline x of fot, if it exists\n        iy (np.ndarray(float)): spline y of fot, if it exists\n        iyaw (np.ndarray(float)): spline yaws of fot, if it exists\n        d (np.ndarray(float)): lateral offset of fot, if it exists\n        s (np.ndarray(float)): longitudinal offset of fot, if it exists\n        speeds_x (np.ndarray(float)): x speeds of fot, if it exists\n        speeds_y (np.ndarray(float)): y speeds of fot, if it exists\n        params (dict): next frenet coordinates, if they exist\n        costs (dict): costs of best frenet path, if it exists\n        success (bool): whether a fot was found or not\n\n")),(0,a.kt)("p",null,"Ref: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/erdos-project/frenet_optimal_trajectory_planner/blob/master/FrenetOptimalTrajectory/fot_wrapper.py"},"https://github.com/erdos-project/frenet_optimal_trajectory_planner/blob/master/FrenetOptimalTrajectory/fot_wrapper.py")))}d.isMDXComponent=!0}}]);