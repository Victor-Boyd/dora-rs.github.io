"use strict";(self.webpackChunkdora_rs_github_io=self.webpackChunkdora_rs_github_io||[]).push([[2458],{3905:(n,o,e)=>{e.d(o,{Zo:()=>c,kt:()=>b});var t=e(7294);function a(n,o,e){return o in n?Object.defineProperty(n,o,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[o]=e,n}function i(n,o){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(n);o&&(t=t.filter((function(o){return Object.getOwnPropertyDescriptor(n,o).enumerable}))),e.push.apply(e,t)}return e}function r(n){for(var o=1;o<arguments.length;o++){var e=null!=arguments[o]?arguments[o]:{};o%2?i(Object(e),!0).forEach((function(o){a(n,o,e[o])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):i(Object(e)).forEach((function(o){Object.defineProperty(n,o,Object.getOwnPropertyDescriptor(e,o))}))}return n}function l(n,o){if(null==n)return{};var e,t,a=function(n,o){if(null==n)return{};var e,t,a={},i=Object.keys(n);for(t=0;t<i.length;t++)e=i[t],o.indexOf(e)>=0||(a[e]=n[e]);return a}(n,o);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);for(t=0;t<i.length;t++)e=i[t],o.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(n,e)&&(a[e]=n[e])}return a}var s=t.createContext({}),p=function(n){var o=t.useContext(s),e=o;return n&&(e="function"==typeof n?n(o):r(r({},o),n)),e},c=function(n){var o=p(n.components);return t.createElement(s.Provider,{value:o},n.children)},_="mdxType",d={inlineCode:"code",wrapper:function(n){var o=n.children;return t.createElement(t.Fragment,{},o)}},u=t.forwardRef((function(n,o){var e=n.components,a=n.mdxType,i=n.originalType,s=n.parentName,c=l(n,["components","mdxType","originalType","parentName"]),_=p(e),u=a,b=_["".concat(s,".").concat(u)]||_[u]||d[u]||i;return e?t.createElement(b,r(r({ref:o},c),{},{components:e})):t.createElement(b,r({ref:o},c))}));function b(n,o){var e=arguments,a=o&&o.mdxType;if("string"==typeof n||a){var i=e.length,r=new Array(i);r[0]=u;var l={};for(var s in o)hasOwnProperty.call(o,s)&&(l[s]=o[s]);l.originalType=n,l[_]="string"==typeof n?n:a,r[1]=l;for(var p=2;p<i;p++)r[p]=e[p];return t.createElement.apply(null,r)}return t.createElement.apply(null,e)}u.displayName="MDXCreateElement"},3843:(n,o,e)=>{e.r(o),e.d(o,{assets:()=>s,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var t=e(7462),a=(e(7294),e(3905));const i={},r="Obstacle location operator",l={unversionedId:"nodes_operators/obstacle_location_op",id:"nodes_operators/obstacle_location_op",title:"Obstacle location operator",description:"The obstacle location operator match bounding box with depth frame to find an approximative position of obstacles.",source:"@site/docs/nodes_operators/obstacle_location_op.md",sourceDirName:"nodes_operators",slug:"/nodes_operators/obstacle_location_op",permalink:"/docs/nodes_operators/obstacle_location_op",draft:!1,editUrl:"https://github.com/dora-rs/dora-rs.github.io/edit/main/docs/nodes_operators/obstacle_location_op.md",tags:[],version:"current",frontMatter:{},sidebar:"nodes_operators",previous:{title:"MiDaS",permalink:"/docs/nodes_operators/midas_op"},next:{title:"PID Control operator",permalink:"/docs/nodes_operators/pid_control_op"}},s={},p=[{value:"Inputs",id:"inputs",level:2},{value:"Outputs",id:"outputs",level:2},{value:"Graph Description",id:"graph-description",level:2},{value:"Graph Viz",id:"graph-viz",level:2},{value:"Methods",id:"methods",level:2},{value:"<code>__init__()</code>",id:"__init__",level:3},{value:"<code>.on_event(...)</code>",id:"on_event",level:3},{value:"<code>.on_input(...)</code>",id:"on_input",level:3}],c={toc:p},_="wrapper";function d(n){let{components:o,...e}=n;return(0,a.kt)(_,(0,t.Z)({},c,e,{components:o,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"obstacle-location-operator"},"Obstacle location operator"),(0,a.kt)("p",null,"The obstacle location operator match bounding box with depth frame to find an approximative position of obstacles."),(0,a.kt)("p",null,"There is two logic within it:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"One is for the ground dot for lane detection."),(0,a.kt)("li",{parentName:"ul"},"One is for bounding box obstacle localisation.")),(0,a.kt)("p",null,"Both logic are based on he computation of the projection in 2D space of the lidar 3D point and then reusing the index to get the 3D position."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"In the case of ground dot detection, the approximation is based on a knnr, as we might not have enough data on the floor."),(0,a.kt)("li",{parentName:"ul"},"In the case of bounding box, we use first quantile closest point within the bounding box to estimate the distance. We use the first quantile closest point to remove the noise.")),(0,a.kt)("p",null,"The mecanism to project the lidar point cloud into a 2D is also used in the ",(0,a.kt)("inlineCode",{parentName:"p"},"plot.py")," operator. You can use the input ",(0,a.kt)("inlineCode",{parentName:"p"},"lidar_pc")," within it to help you debug."),(0,a.kt)("h2",{id:"inputs"},"Inputs"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"2D Obstacles bounding box.")),(0,a.kt)("h2",{id:"outputs"},"Outputs"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"3D position of obstacles as dot.")),(0,a.kt)("h2",{id:"graph-description"},"Graph Description"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"  - id: obstacle_location_op\n    operator: \n      outputs:\n        - obstacles\n      inputs:\n        lidar_pc: oasis_agent/lidar_pc\n        obstacles_bbox: yolov5/bbox\n        position: oasis_agent/position\n      python: ../../operators/obstacle_location_op.py\n")),(0,a.kt)("h2",{id:"graph-viz"},"Graph Viz"),(0,a.kt)("mermaid",{value:"        flowchart TB\n  oasis_agent\nsubgraph yolov5\n  yolov5/op[op]\nend\nsubgraph fot_op\n  fot_op/op[op]\nend\nsubgraph obstacle_location_op\n  obstacle_location_op/op[op]\nend\n  oasis_agent -- lidar_pc --\x3e obstacle_location_op/op\n  yolov5/op -- bbox as obstacles_bbox --\x3e obstacle_location_op/op\n  oasis_agent -- position --\x3e obstacle_location_op/op\n  obstacle_location_op/op -- obstacles --\x3e fot_op/op"}),(0,a.kt)("h2",{id:"methods"},"Methods"),(0,a.kt)("h3",{id:"__init__"},(0,a.kt)("inlineCode",{parentName:"h3"},"__init__()")),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Source Code"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"    def __init__(self):\n        self.point_cloud = []\n        self.camera_point_cloud = []\n        self.ground_point_cloud = []\n        self.camera_ground_point_cloud = []\n        self.last_point_cloud = []\n        self.last_camera_point_cloud = []\n        self.obstacles = []\n        self.obstacles_bbox = []\n        self.position = []\n        self.lanes = []\n\n\n"))),(0,a.kt)("h3",{id:"on_event"},(0,a.kt)("inlineCode",{parentName:"h3"},".on_event(...)")),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Source Code"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'\n    def on_event(\n        self,\n        dora_event: dict,\n        send_output: Callable[[str, bytes], None],\n    ) -> DoraStatus:\n        if dora_event["type"] == "INPUT":\n            return self.on_input(dora_event, send_output)\n        return DoraStatus.CONTINUE\n\n\n'))),(0,a.kt)("h3",{id:"on_input"},(0,a.kt)("inlineCode",{parentName:"h3"},".on_input(...)")),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Source Code"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},'\n    def on_input(\n        self,\n        dora_input: dict,\n        send_output: Callable[[str, bytes], None],\n    ):\n        if "lidar_pc" == dora_input["id"]:\n            point_cloud = np.array(dora_input["value"])\n            point_cloud = point_cloud.reshape((-1, 3))\n\n            # From Velodyne axis to Camera axis\n            # from Velodyne axis:\n            # x -> forward, y -> right, z -> top\n            # to Camera axis:\n            # x -> right, y -> bottom, z -> forward\n            point_cloud = np.dot(\n                point_cloud,\n                VELODYNE_MATRIX,\n            )\n\n            # Forward points only ( forward = z > 0.1 )\n            point_cloud = point_cloud[np.where(point_cloud[:, 2] > 0.1)]\n\n            # Remove ground points. Above lidar only ( bottom = y < 1.0 )\n            above_ground_point_index = np.where(point_cloud[:, 1] < 1.0)\n            point_cloud = point_cloud[above_ground_point_index]\n            self.ground_point_cloud = point_cloud[above_ground_point_index == False]\n\n            # 3D array -> 2D array with index_x -> pixel x, index_y -> pixel_y, value -> z\n            camera_point_cloud = local_points_to_camera_view(\n                point_cloud, INTRINSIC_MATRIX\n            ).T\n            self.camera_ground_point_cloud = local_points_to_camera_view(\n                self.ground_point_cloud, INTRINSIC_MATRIX\n            ).T\n\n            self.camera_point_cloud = camera_point_cloud\n            self.point_cloud = point_cloud\n\n        elif "position" == dora_input["id"]:\n            # Add sensor transform\n            self.position = dora_input["value"].to_numpy()\n            self.extrinsic_matrix = get_extrinsic_matrix(\n                get_projection_matrix(self.position)\n            )\n\n        elif "lanes" == dora_input["id"]:\n            lanes = np.array(dora_input["value"]).reshape((-1, 60, 2))\n\n            knnr = KNeighborsRegressor(n_neighbors=4)\n            knnr.fit(self.camera_ground_point_cloud[:, :2], self.ground_point_cloud)\n\n            processed_lanes = []\n            for lane in lanes:\n                lane_location = knnr.predict(lane)\n                lane_location = np.array(lane_location)\n\n                lane_location = np.hstack(\n                    (\n                        lane_location,\n                        np.ones((lane_location.shape[0], 1)),\n                    )\n                )\n                lane_location = np.dot(lane_location, self.extrinsic_matrix.T)[:, :3]\n                processed_lanes.append(lane_location)\n            processed_lanes = pa.array(np.array(processed_lanes, np.float32).ravel())\n\n            send_output("global_lanes", processed_lanes, dora_input["metadata"])\n\n        elif "obstacles_bbox" == dora_input["id"]:\n            if len(self.position) == 0 or len(self.point_cloud) == 0:\n                return DoraStatus.CONTINUE\n\n            # bbox = np.array([[min_x, max_x, min_y, max_y, confidence, label], ... n_bbox ... ])\n            self.obstacles_bbox = np.array(dora_input["value"]).reshape((-1, 6))\n\n            obstacles_with_location = []\n            for obstacle_bb in self.obstacles_bbox:\n                [min_x, max_x, min_y, max_y, confidence, label] = obstacle_bb\n                z_points = self.point_cloud[\n                    np.where(\n                        (self.camera_point_cloud[:, 0] > min_x)\n                        & (self.camera_point_cloud[:, 0] < max_x)\n                        & (self.camera_point_cloud[:, 1] > min_y)\n                        & (self.camera_point_cloud[:, 1] < max_y)\n                    )\n                ]\n                if len(z_points) > 0:\n                    closest_point = z_points[\n                        z_points[:, 2].argsort()[int(len(z_points) / 4)]\n                    ]\n                    obstacles_with_location.append(closest_point)\n            if len(obstacles_with_location) > 0:\n                obstacles_with_location = np.array(obstacles_with_location)\n                obstacles_with_location = np.hstack(\n                    (\n                        obstacles_with_location,\n                        np.ones((obstacles_with_location.shape[0], 1)),\n                    )\n                )\n                obstacles_with_location = np.dot(\n                    obstacles_with_location, self.extrinsic_matrix.T\n                )[:, :3]\n\n                predictions = get_predictions(\n                    self.obstacles_bbox, obstacles_with_location\n                )\n                predictions_bytes = pa.array(np.array(predictions, np.float32).ravel())\n\n                send_output("obstacles", predictions_bytes, dora_input["metadata"])\n            else:\n                send_output(\n                    "obstacles",\n                    pa.array(np.array([]).ravel()),\n                    dora_input["metadata"],\n                )\n        return DoraStatus.CONTINUE\n\n\n'))))}d.isMDXComponent=!0}}]);